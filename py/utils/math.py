# Licensed under the Apache License, Version 2.0 (the "License");
# Copyright 2024 Ã˜ivind Loe
# See LICENSE file or http://www.apache.org/licenses/LICENSE-2.0 for details.
# ~

from typing import Any

import numpy as np


# Maps an input value in an input range to an output value in an output range
# Caps output range
def mapRanges(inRange: tuple[float, float], outRange: tuple[float, float], value: float) -> float:
    value = max(min(value, inRange[1]), inRange[0])  # Cap input
    return (value - inRange[0]) / (inRange[1] - inRange[0]) * (outRange[1] - outRange[0]) + outRange[0]


# Round number or list to specified precision, and output as strings
def pround(inp: Any, p: int = 2) -> Any:
    if isinstance(inp, (list, tuple, np.ndarray)):
        return [pround(v, p) for v in inp]

    if isinstance(inp, int):
        return str(inp)

    return ('{:.' + str(p) + 'f}').format(inp)


# Round number or list to specified precision, and output as strings
def spround(inp: Any, p: int = 2) -> str:
    if isinstance(inp, (list, tuple, np.ndarray)):
        return '[' + ', '.join([pround(v, p) for v in inp]) + ']'

    if isinstance(inp, int):
        return str(inp)

    return ('{:.' + str(p) + 'f}').format(inp)


def avg(inp: Any, default: float = 0) -> float:
    if not isinstance(inp, list):
        inp = list(inp)
    return sum(inp) / len(inp) if len(inp) > 0 else default


# Percentile prep and calculation
def percentilePrep(values: list[float], targetSegments: int) -> Any:

    # Prep and sort list
    vec = np.array(values, dtype='float')
    vec = np.sort(vec)

    # If less values than target segments, no segmentation needed
    valueCount = vec.shape[0]
    if valueCount <= targetSegments:
        return vec

    splitPoints = np.around([valueCount * i / targetSegments for i in range(1, targetSegments)]).astype('int')

    # Return value contains starting point of each group, and then at the end the very last and largest item if not already in the list
    ret = [v[0] for v in np.split(vec, splitPoints)]
    if ret[-1] != vec[-1]:
        ret.append(vec[-1])

    return np.array(ret)


def percentile(value: float, prepValues: Any, outRange: tuple[int, int] = (1, 100)) -> int:
    """
    :param prepValues: generated by percentilePrep
    :param value:      value to calculate percentile for
    :returns:          an integer in the inclusive range of outRange
    """

    size = prepValues.shape[0]
    if size == 0:
        return 0

    # Need to find the highest and lowest value of prepValues and pick the center to deal with cases
    # where there are large volumes of the same value in the dataset -> prepValues contains multiple of the same value
    first = np.searchsorted(prepValues, value, side='left')
    last = np.searchsorted(prepValues, value, side='right')

    # If prepValues has N entries, there are 2*N+1 possible output values, one for a value hitting each entry exactly,
    # and one for each value hitting in between or outside any of the entries
    fraction = (outRange[1] - outRange[0]) / (2 * size)  # 2*N+1 includes 0 value

    # Deal with case where value is on top of one of prepValues first, then in-between
    if first < size and value == prepValues[first]:
        # Hitting on one of the values gives an odd index into the possible output values
        return int((2 * first + 1) * fraction + outRange[0])

    # Hitting in-between (or outside) the values gives an even index into possible output values, including the lowest value
    # Firt + last is already 2x so no need to multiply with 2
    return int((first + last) * fraction + outRange[0])
